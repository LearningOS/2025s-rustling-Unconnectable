/*
 * Rust 的 FFI 接口
 *
 * Rust 能够非常高效地与 C/C++ 以及其他静态编译语言共享 FFI(外部函数接口),
 * 甚至可以在代码内部进行链接！这是通过 `extern` 块实现的,如下面的代码所示.
 *
 * ## `extern` 关键字
 *
 * 在 `extern` 关键字后的短字符串表示外部导入函数所遵循的 ABI(应用二进制接口).
 * 在本练习中,使用了 "Rust",但其他变体也存在,例如 "C" 表示标准 C ABI,
 * "stdcall" 表示 Windows ABI.
 *
 * 外部导入的函数在 `extern` 块中声明,使用分号标记签名结束,而不是大括号.
 * 可以对这些函数声明应用一些属性来修改链接行为,例如 `#[link_name = ".."]`
 * 来修改实际的符号名称.
 *
 * ## 导出符号
 *
 * 如果你想将符号导出到链接环境中,可以在函数定义前使用相同的 ABI 字符串标记 `extern` 关键字.
 * Rust 函数的默认 ABI 是 "Rust",因此如果你想链接纯 Rust 函数,可以完全省略 `extern` 关键字.
 *
 * ## 符号修饰(Mangling)
 *
 * Rust 默认会对符号进行修饰(mangling),就像 C++ 一样.为了抑制这种行为并使这些函数
 * 可以通过名称寻址,可以应用 `#[no_mangle]` 属性.
 *
 * ## 本练习任务
 *
 * 在本练习中,你的任务是使测试用例能够调用模块 `Foo` 中的 `my_demo_function`.
 * `my_demo_function_alias` 是 `my_demo_function` 的别名,因此测试用例中的两行代码
 * 应该调用相同的函数.
 *
 * **注意**：你不应修改任何现有代码,只需添加两行属性.
 */

/*
 * 外部导入的函数默认是 UNSAFE 的,
 * 因为它们来自不受信任的其他语言.你可以
 * 将它们包装在安全的 Rust API 中以减轻调用者的负担.
 *
 * SAFETY: 我们知道这些函数是一个安全的 Rust 函数的别名.
 */

/*
 * 示例代码
 */

/*
// 外部导入的函数默认是 UNSAFE 的
extern "Rust" {
    fn my_demo_function(a: u32) -> u32;
    fn my_demo_function_alias(a: u32) -> u32;
}

// 你可以在这里添加属性
*/